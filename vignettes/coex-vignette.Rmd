---
title: "coex"
subtitle: "An R package for straightforward co-expression analyses"
output: BiocStyle::html_document
#output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(coex)
library(magrittr)
library(recount)
library(stringr)
```

Load data from SRP041675 as a RangedSummarizedExperiment. This loads an object named `rse_gene`.
```{r}
file_url <- download_study('SRP041675', type = "rse-gene",
                           download = FALSE)

# Load the data
load(file = url(file_url))
rse_gene
```


```{r, eval=FALSE}
load("~/Desktop/rse-gene.Rdata")
```

Load the gene expression counts into a coexList object
```{r}
cl <- coexList(counts = assay(rse_gene))
```

Add the gene and sample metadata to the coexList object
```{r}
colData(cl) <- colData(rse_gene)
rowData(cl) <- rowData(rse_gene)
```

Reformat some of the metadata for analysis purposes
```{r}
group_df <- colData(cl)$title %>% 
    stringr::str_split(pattern = "_", n = 3, simplify = TRUE) %>%
    DataFrame()
group_df$V3[group_df$V2 == "Fresh"] <- "None"
group_df$V1 <- colnames(cl)
colnames(group_df) <- c("Sample", "Timepoint", "Treatment")

colData(cl) <- group_df[ ,c(2:3)]
rownames(colData(cl)) <- group_df[ ,1]
```


Now we can remove the `rse_gene` object
```{r}
rm(rse_gene)
```


## Counts filtering

```{r}
hist(edgeR::cpm(assay(cl), log=TRUE))
```

```{r}
keep <- edgeR::filterByExpr(assay(cl))
hist(edgeR::cpm(assay(cl)[keep, ], log=TRUE))

cl <- cl[keep, ]
```


## Normalisation

The goal of within sample normalisation is...

Count per million normalisation
```{r}
cl <- normCounts(cl, normMethod = "CPM")
```

CTF normalisation as described in... 

Normalise the data for co-expression calculations using the CTF method and scale using `asinh()`.
https://github.com/krishnanlab/RNAseq_coexpression/blob/main/src/CTF_normalize.R
```{r}
cl2 <- normCounts(cl, normMethod = "CTF", scaleMethod = "asinh")
```


## Clustering

First, lets do some plots to inspect for any batch effects or outlier samples

PCA plot
```{r, eval=FALSE}
pca_cpm_treat <- plotPCA(cl, groupVar = "Treatment") + ggtitle("CPM")
pca_ctf_treat <- plotPCA(cl2, groupVar = "Treatment") + ggtitle("CTF")

pca_cpm_time <- plotPCA(cl, groupVar = "Timepoint") + ggtitle("CPM")
pca_ctf_time <- plotPCA(cl2, groupVar = "Timepoint") + ggtitle("CTF")

cowplot::plot_grid(pca_cpm_treat, pca_ctf_treat,
                   pca_cpm_time, pca_ctf_time)
```


Hierarchical clustering
```{r}
plotDendrogram <- function(cl, colVar=1, corMethod="spearman",
                            hclustMethod="average"){
 
        # Do the clustering
        cat("Calculating correlations...\n")
        dissimilarity <- 1 - cor(cl@normCounts, method = corMethod)
        cat("Clustering...\n")
        distance <- as.dist(dissimilarity)
        hc <- hclust(distance, method = hclustMethod)
        gg1 <- suppressMessages(
            ggdendro::ggdendrogram(hc, rotate = FALSE, labels = TRUE) +
            ggplot2::scale_x_discrete(expand=c(0,0)) + 
            ggplot2::scale_y_continuous(expand = c(0,0)) +
            ggplot2::theme(axis.text.y = ggplot2::element_text(angle = 0),
                  plot.margin = ggplot2::unit(c(10,10,0,10), "points"))
        )
        
        # Get the colData for colour bar    
        get_col_data <- function(x){
            df <- data.frame(id = rownames(colData(cl)),
                                    variable = colnames(colData(cl))[x],
                                    value = colData(cl)[ ,x],
                                    order = hc$order)
            
            # Set order of dendrogram
            df$id <- factor(df$id, levels = hc$labels[hc$order])
            
            return(df)
        }
        
        col_dat <- get_col_data(x = colVar)

        # Plot the colour bar
        gg2 <- ggplot2::ggplot(col_dat, aes(x = .data$id,
                                   y = .data$variable,
                                   fill=.data$value)) +
            ggplot2::geom_tile() + 
            ggplot2::scale_x_discrete(expand = c(0,0)) +
            ggplot2::scale_y_discrete(expand=c(0,0)) +
            ggplot2::scale_fill_viridis_d() +
            ggplot2::xlab("") +
            ggplot2::ylab("") +
            ggplot2::theme(plot.margin = unit(c(0,10,10,10), "points"),
                  axis.ticks = ggplot2::element_blank(),
                  axis.text.x = ggplot2::element_blank(),
                  axis.text.y = element_text(angle = 0),
                  legend.title = element_blank(),
                  legend.position="bottom")

        # Assemble the plot
        cp <- cowplot::plot_grid(gg1, gg2, axis = "l", align = "v",
                                 nrow = 2,
                                 rel_heights = c(0.4, 0.2))

        return(cp)
}
```


```{r}
plotDendrogram(cl = cl, colVar = 1)
```



Filter the data
```{r, eval=FALSE}
checkFilter(cl, propGenes = 0.1)
cl <- applyFilter(cl, propGenes = 0.1)
```

Calculate soft power thresholds for WGCNA network
```{r, eval=FALSE}
cl <- calcSoftPower(cl)
```

Check what the estimated power is
```{r, eval=FALSE}
cl@powerEstimate
```
Plot soft power estimates
```{r, eval=FALSE}
plotSoftPower(cl)
```

Calc adjacency matrix
```{r, eval=FALSE}
cl <- calcAdjacency(cl, method = "wgcna", softPower = 5)
```

Calculate topological overlap matrix (TOM)
```{r, eval=FALSE}
cl <- calcTOM(cl)
```
Cluster genes
```{r, eval=FALSE}
cl <- calcTree(cl)
```

Plot clustering
```{r, eval=FALSE}
plotTree(cl, pamStage=TRUE)
```

Plot the modules for groups
```{r, eval=FALSE}

```


